<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hzy]]></title>
    <url>%2F2018%2F12%2F02%2Fhzy%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Immutable 常用方法]]></title>
    <url>%2F2018%2F12%2F02%2FImmutable%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这里主要整理一下项目中用到的 Immutable 相关方法，第一次使用可能有点生疏，还是需要对照文档。但是部分方法确实高效，封装了原生 JS 的方法，同时也集成了 lodash 的一些方法。 Immutable 官网文档 Immutable 常见数据类型 List: 有序索引集，类似 JavaScript 中的 Array。 Map: 无序索引集，类似 JavaScript 中的 Object。 Seq: 序列，但是可能不能由具体的数据结构支持。 OrderedMap: 有序的 Map，根据数据的 set()进行排序。 Set: 没有重复值的集合。 OrderedSet: 有序的 Set，根据数据的 add 进行排序。 Stack: 有序集合，支持使用 unshift（）和 shift（）添加和删除。 Range(): 返回一个 Seq.Indexed 类型的集合，这个方法有三个参数，start 表示开始值，默认值为 0，end 表示结束值，默认为无穷大，step 代表每次增大的数值，默认为 1.如果 start = end,则返回空集合。 Repeat(): 返回一个 vSeq.Indexe 类型的集合，这个方法有两个参数，value 代表需要重复的值，times 代表要重复的次数，默认为无穷大。 Record: 一个用于生成 Record 实例的类。类似于 JavaScript 的 Object，但是只接收特定字符串为 key，具有默认值。 Collection: 是构建所有数据结构的基类，不可以直接构建。 常用API fromJS() 作用：将一个 js 数据转换为 Immutable 类型的数据。用法：fromJS(value, converter)简介：将一个对象自动转化成 Map，将一个数组自动转换成 List，只能实现一层的转化 12345const defaultState = fromJS(&#123; total: 0, pay: false, selectAll: false&#125;) toJS() 作用：将一个 Immutable 数据转换为 JS 类型的数据。用法：value.toJS()简介：将一个 Map 自动转化成对象，将一个 List 自动转换成数组，只能实现一层的转化 is() equals() 作用：对两个对象进行比较。用法：is(map1,map2) map1.equals(map2)简介：返回值为一个 Boolean，和原生 JS 比较不同的是，这个比较的是两个对象的存储地址，就算值相同，存储地址不同，返回值也是 false ，可以用 ‘===’实现相同功能 123456const map1 = Map(&#123; a: 1, b: 2, c: 3&#125;)const map2 = Map(&#123; a: 1, b: 2, c: 3&#125;)console.log(map1.equals(map2)) // trueconsole.log(map1 == map2) // falseconsole.log(map1 === map2) // falseconsole.log(is(map1, map2) // true List Map 作用：创建 Immutable 的 List 和 Map 对象用法：List() Map() get() getIn() 作用：获取对象的具体值。用法：get(index: number): T | undefinedgetIn(searchKeyPath: Iterable, notSetValue?: any): any简介：get()只能查找一层的 List 或者 Map，getIn()可以对多层的 List 或者 Map 进行取值，需要用数组的方法输入路径。 12345const nested = fromJS(&#123; a: &#123; b: &#123; c: [ 3, 4, 5 ] &#125; &#125; &#125;)console.log(nested.get('a'))//Map &#123; "b": Map &#123; "c": List [ 3, 4, 5 ] &#125; &#125;console.log(nested.getIn([ 'a', 'b', 'c' , 0 ]))//3 set() setIn() 作用：设置对象的具体值。用法：set(index: number, value: T): ListsetIn(keyPath: Iterable, value: any): this简介：同上12345const nested = fromJS(&#123; a: &#123; b: &#123; c: [ 3, 4, 5 ] &#125; &#125; &#125;)console.log(nested.set('a',1))//Map &#123; "a" :1 &#125;console.log(nested.getIn([ 'a', 'b', 'c' , 0 ]),0)// Map &#123; "a": Map &#123; "b": Map &#123; "c": List [ 0, 4, 5 ] &#125; &#125; &#125; updateIn() 作用：更新对象的具体值。用法：updateIn(keyPath: Iterable,notSetValue: any,updater: (value: any) =&gt; any): thisupdateIn(keyPath: Iterable, updater: (value: any) =&gt; any): this简介：更新相关对象，回调函数中处理后返回一个新的状态。1let newProducts1 = state.updateIn(['products'], list =&gt; list.push(1)) delete() deleteIn() 作用：删除数组中的值或者对象的属性。用法：delete(index: number): Listdelete(key: K): thisdeleteIn(keyPath: Iterable): this12list.delete(1);list.deleteIn([0,1]); groupBy() 作用：对数据进行分组12345678910111213const listOfMaps = List([ Map(&#123; v: 0 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 0 &#125;), Map(&#123; v: 2 &#125;)])const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))// Map &#123;// 0: List [ Map&#123; "v": 0 &#125;, Map &#123; "v": 0 &#125; ],// 1: List [ Map&#123; "v": 1 &#125;, Map &#123; "v": 1 &#125; ],// 2: List [ Map&#123; "v": 2 &#125; ],// &#125; indexOf() lastIndexOf() 作用：和js数组中的方法相同，查找第一个或者最后一个value的index值，找不到则返回-1简介：Map不存在此方法 findIndex() findLastIndex() 作用：查找满足要求的元素的index值简介：Map不存在此方法 Seq() 作用：将集合转化成seq123const &#123; Map &#125; = require('immutable')const map = Map(&#123; a: 1, b: 2, c: 3 &#125;const lazySeq = Seq(map) Seq 允许有效链接操作，允许表达逻辑12345lazySeq .flip() .map(key =&gt; key.toUpperCase()) .flip()// Seq &#123; A: 1, B: 1, C: 1 &#125; 总结&emsp;&emsp;总体来说，Immutable的用法并没有这么繁琐，只要在使用的时候保持清醒的头脑，永远记住操作完返回一个新的状态久好了。其他一些零零碎碎的方法反正和原生JS类似啦，骚年，征服Immutable这个小妖精变得so easy!!!]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何在React-Native上使用Typescript]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%A6%82%E4%BD%95%E5%9C%A8React-Native%E4%B8%8A%E4%BD%BF%E7%94%A8Typescript%2F</url>
    <content type="text"><![CDATA[创建React-Native项目 安装脚手架 yarn global add create-react-native-app 创建项目 create-react-native-app 项目名称 进入项目并启动 cd xxxyarn start 如果不使用Typescript，现在就可以经行RN的项目开发了，但是要使用Typescript，还需要折腾一番。 配置Typescript开发依赖 安装ts依赖 这里安装ts语言依赖，同时将react的一些包安装到 @types文件夹内，不然写react代码的时候会报找不到react包依赖 yarn add typescript tslint -Dyarn add @types/react @types/react-native @types/react-dom -D 我们还需要concurrently来实时监听文件变化，rimraf，并发地清理从ts编译过来的js文件的输出文件夹，并发地运行npm脚本. yarn add concurrently rimraf -D 配置ts文件 在根目录下手动创建tsconfig.json文件，将下面的代码直接复制进去123456789101112131415161718192021222324252627282930313233343536373839&#123; "compilerOptions": &#123; "module":"es2015", "target": "es2015", "jsx": "react", "rootDir": "src", "outDir": "build", "allowSyntheticDefaultImports": true, "noImplicitAny": true, "sourceMap": true, "experimentalDecorators": true, "preserveConstEnums": true, "allowJs": true, "noUnusedLocals": true, "noUnusedParameters": true, "noImplicitReturns": true, "skipLibCheck": true, "moduleResolution":"Node" &#125;, "filesGlob": [ "typings/index.d.ts", "src/**/*.ts", "src/**/*.tsx", "node_modules/typescript/lib/lib.es6.d.ts" ], "types": [ "react", "react-dom", "react-native" ], "exclude":[ "build", "node_modules", "jest.config.js", "App.js" ], "compileOnSave": false&#125; 需要注意一些细节： 我们希望将Typescript应用程序的所有代码存储在src文件夹下的文件夹/子文件夹中。用“rootDir”:“src“，确保你的根目录为src或者也可以手动更改 并把babel.config.js文件扔到这个文件夹内 安装npm脚本的依赖，方便打包和运行 yarn add react-native-scripts 将package.json中的scripts代替为下面的配置123456789101112131415161718'script':&#123; "start": "react-native-scripts start", "eject": "react-native-scripts eject", "android": "react-native-scripts android", "ios": "react-native-scripts ios", "test": "node node_modules/jest/bin/jest.js", "lint": "tslint src/**/*.ts", "tsc": "tsc", "clean": "rimraf build", "build": "yarn run clean &amp;&amp; yarn run tsc --", "watch": "yarn run build -- -w", "watchAndRunAndroid": "concurrently \"yarn run watch\" \"yarn run android\"", "buildRunAndroid": "yarn run build &amp;&amp; yarn run watchAndRunAndroid ", "watchAndRunIOS": "concurrently \"yarn run watch\" \"yarn run ios\"", "buildRunIOS": "yarn run build &amp;&amp; yarn run watchAndRunIOS ", "watchAndStart": "concurrently \"yarn run watch\" \"yarn run start\"", "buildAndStart": "yarn run build &amp;&amp; yarn run watchAndStart "&#125; 将main更改为： “main”:”./node_modules/react-nativescripts/build/bin/crna-entry.js” 这意味着我们的应用程序从这个crna-entry.js 开始。打开这个文件，你会发现它引用了我们的App.js var _App = require(‘../../../../App’); 修改App.js文件 12import App from './build/App';export default App; 注意创建typescript文件后缀为.tsx 启动任务 运行命令即可,直接打包并且启动任务，这可能需要一些事件，少侠请耐心等候。 yarn buildAndStart]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable.js之我见]]></title>
    <url>%2F2018%2F11%2F30%2FImmutable.js%E4%B9%8B%E6%88%91%E8%A7%81%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;本文主要介绍facebook推出的一个类库immutable.js，以及如何将immutable.js集成到我现有的react+redux架构的移动端项目中。 一.immutable.js介绍 原生js在redux中处理数据的坑&emsp;&emsp;前两天在处理购物车的redux逻辑的时候，遇到一个问题，全选反选的功能和逻辑没有问题，改变后的数据在reducer中打印出来也已经是正确的改变，但是页面中的元素就是不会发生改变，甚至不会重新执行render()的生命周期。123456789101112131415161718//获取存储的购物车商品信息let products = state.products//根据传入的id 查找并修改这个物品的选中状态for (let i = 0; i &lt; products.length; i++) &#123; if (products[i].id === action.id) &#123; products[i].select = action.isSelect break; &#125; else &#123; continue &#125;&#125;//返回新的状态return &#123; ...state, products,&#125;&emsp;&emsp;乍一看好像没有问题，找了好久才发现在reducer中处理数据的时候使用了地址引用，导致返回的还是原来的对象，状态没有发生改变。React对于状态变化的感知是必须返回的新对象才会引起状态的变化，从而去渲染页面。下面才是正常的代码。12//获取存储的购物车商品信息let products = state.products&emsp;&emsp;在js中，引用类型的数据，优点在于频繁的操作数据都是在原对象的基础上修改，不会创建新对象，从而可以有效的利用内存，不会浪费内存，这种特性称为mutable（可变），但恰恰它的优点也是它的缺点，太过于灵活多变在复杂数据的场景下也造成了它的不可控性，假设一个对象在多处用到，在某一处不小心修改了数据，其他地方很难预见到数据是如何改变的，针对这种问题的解决方法，一般就像刚才的例子，会想复制一个新对象，再在新对象上做修改，这无疑会造成更多的性能问题以及内存浪费。 为了解决这种问题，出现了immutable对象，每次修改immutable对象都会创建一个新的不可变对象，而老的对象不会改变。immutable.js介绍immutable.js主要有三大特性： Persistent data structure （持久化数据结构） 一般听到持久化，在编程中第一反应应该是，数据存在某个地方，需要用到的时候就能从这个地方拿出来直接使用 但这里说的持久化是另一个意思，用来描述一种数据结构，一般函数式编程中非常常见，指一个数据，在被修改时，仍然能够保持修改前的状态，从本质来说，这种数据类型就是不可变类型，也就是immutable immutable.js提供了十余种不可变的类型（List，Map，Set，Seq，Collection，Range等） structural sharing （结构共享） immutable使用先进的tries(字典树)技术实现结构共享来解决性能问题，当我们对一个Immutable对象进行操作的时候，ImmutableJS会只clone该节点以及它的祖先节点，其他保持不变，这样可以共享相同的部分，大大提高性能。* support lazy operation （惰性操作） 这里有一个新的数据类型Seq，它有跟原生js类似的方法，但是性能却远远优于原生js123456789Immutable.Seq.of(1,2,3,4,5,6,7,8).filter(x=&gt;&#123; console.log('Immutable执行') return x%2&#125;)[1,2,3,4,5,6,7,8].filter(x=&gt;&#123; console.log('原生js执行') return x%2&#125;) 结果是上面的只执行3次，下面的代码执行了8次。 那么对于高频率的大量数据处理，这就意味着性能的优化。immutable.js的优缺点 优点 降低mutable带来的复杂度，甚至可以省略loadsh或者underscore的引入 节省内存 历史追溯性（时间旅行）：时间旅行指的是，每时每刻的值都被保留了，想回退到哪一步只要简单的将数据取出就行，想一下如果现在页面有个撤销的操作，撤销前的数据被保留了，只需要取出就行，这个特性在redux或者flux中特别有用 拥抱函数式编程：immutable本来就是函数式编程的概念，纯函数式编程的特点就是，只要输入一致，输出必然一致，相比于面向对象，这样开发组件和调试更方便 缺点 需要重新学习api 容易与原生对象混淆：由于api与原生不同，混用的话容易出错。 二.react+redux中集成immutable.js实践 为什么要使用redux中集成immutable React有一个奇怪的令人发指的特性，当一个组件更新的时候，他的子组件或者父组件都会发生更新，可能你只是修改了一个单选钮的样式，但是牵一发动全身，可能变化的是100个组件，所以react有个重要的性能优化的点就是shouldComponentUpdate。z爱这个生命周期钩子中，需要对数据进行比较，如果数据很大，层次很深，靠原生JS方法逐层比较，可能已经吐了，但是immutable.js,超级简。1a===b 明确边界 在redux中，全局state必须是immutable的，这点毋庸置疑是我们使用immutable来优化redux的核心 组件props是通过redux的connect从state中获得的，并且引入immutableJS的另一个目的是减少组件shouldComponentUpdate中不必要渲染，shouldComponentUpdate中比对的是props，如果props是原生JS就失去了优化的意义 组件内部state如果需要提交到store的，必须是immutable，否则不强制 view提交到action中的数据必须是immutable Action提交到reducer中的数据必须是immutable reducer中最终处理state必须是以immutable的形式处理并返回 与服务端ajax交互中返回的callback统一封装，第一时间转换成immutable数据 你体验过绝望么，只要你选择了immutable.js，对不起请忘记原生js，不然你写项目的时候可能就凉凉了。 具体注入方案 redux中，第一步肯定利用combineReducers来合并reducer并初始化state，redux自带的combineReducers只支持state是原生js形式的，所以这里我们需要使用redux-immutable提供的combineReducers来替换原来的方法12345678910import &#123;combineReducers&#125; from 'redux-immutable';import &#123;reducer as shop&#125; from './shop';import &#123;reducer as cart&#125; from './cart';import &#123;reducer as news&#125; from './news'; const rootReducer = combineReducers(&#123; shop, cart, news,&#125;); reducer中的initialState肯定也需要初始化成immutable类型 12345678const defaultState = &#123; products : Immutable.Map(&#123;&#125;);&#125;export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case SET_ERROR: &#125;&#125; 三. 总结 总的来说immutable.js的出现解决了许多原生js的痛点，并且自身对性能方面做了许多的优化处理，而且immuable.js作为和react同期推出的一个产品，完美的契合了react+redux的state流处理，redux的宗旨就是单一数据流，可追溯，这两点恰恰是immutable.js的优势，自然水到渠成，何乐而不为。 当然也不是所有使用react+redux的场景都需要使用immutable.js，建议满足项目足够大，state结构足够复杂的原则，小项目可以手动处理shouldComponentUpdate，不建议使用，得不偿失。 借鉴于big old]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[socket.io实现信息推送]]></title>
    <url>%2F2018%2F11%2F01%2Fsocket-io%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[WebSocket是html5新增加的一种通信协议，目前流行的浏览器都支持这个协。但是今天的主角socket.io将Websocket和轮询 （Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。相比较之下，使用它做实时，双向和基于事件的通信更加方便。 socket.io官网 准备工作 使用express自动生成一个后台文件目录(前提是你已经安装了(express),我习惯用ejs模板，虽然后面用不到。 1express --view=ejs 安装 socket.io，友情提示请在网络质量良好的情况下进行 1yarn add socket.io 起步 由于官网上提供的案例跟我的需求出入，请求的是后端资源。我的项目是前后端分离部署，后台数据更新后，给用户使用的移动端数据进行更新推送。我让后台和移动端项目同时去监听另外一个接口，通过这个接口作为一个桥梁，实现前后端通信。 后端初始化，启动一个本地服务器，端口号为9002 (这个端口应该没人用吧~) 123var server = require('http').createServer();var io = require('socket.io')(server);server.listen(9002); 前端初始化，引入socket.io 的js 文件，然后创建一个io对象，这个对象也监听着本地的9002端口。 12&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"&gt;&lt;/script&gt;var socket = io('http://localhost:9002'); 实现通信 后端通过监听socket.io 提供的事件，监听用户的状态 123456789//用户连接io.on('connection', function(socket)&#123; console.log('a user connected'); //用户断开连接 socket.on('disconnect', function()&#123; console.log('user disconnected'); &#125;);&#125;); 通过监听自定义事件，实现通信 前端，定义事件 1socket.emit('chat message', "hello world"); 后台，捕获事件 123456io.on('connection', function(socket)&#123; //监听前端chat message事件，如果触发，就在后台打印传递的msg socket.on('chat message', function(msg)&#123; console.log('message: ' + msg); &#125;);&#125;); 广播,可以给除了本人外的所有人发送一条信息123io.on('connection'，function(socket) &#123; socket.broadcast.emit('hi'); &#125;); ok,新技能get！撸代码了😭]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建属于自己的博客（二）]]></title>
    <url>%2F2018%2F10%2F05%2F%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说实话，系统提供的主题看起来真的丑，找来找去发现，next这个主题还是可以的，低调奢华有内涵，就很适合我这种高端大气上档次的boy。接下来我就说说怎么使用next主题打造一个狂拽炫酷吊炸天的个人博客，顺便po一下自己在搭建过程中遇到一些的问题和爬坑过程。 next入门 安装主题 在hexo文件夹的根目录下，使用git 下载最新的next主题 git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题，在hexo 的配置文件中，修改字段theme的值为next 验证主题，在命令行中执行下列代码，如果没有报错，就按照显示的地址在本地查看博客吧。 hexo s 设置主题next中有4个主题，可以通过选择 Scheme ，修改next的主题样式，一个一个去试就好了，我还是觉得Pisces比较干净。 设置语言编辑hexo的配置文件， 将字段 language 设置成你所需要的语言，修改完成后需要重新编译静态文件。乡下人英语不好，还是简体中文看着舒服。 language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 设置菜单编辑hexo的配置文件， 将字段 menu下打开需要属性。||前面是对应的页面，后面是icon小图标名称，使用的是fontawesome图标库，直接去fontawesome官网找吧，把名字复制过来替换即可。 menu: home: / || home about: /about/ || user categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive 有些新建的菜单选项可能没有文件夹，在点击时会报404页面，需要手动创建文件夹。可以在hexo根目录下执行下列命令 hexo new page “目录名称” 设置头像和网站的favicon图标编辑next文件夹中的主题配置文件（_config.yml）， 修改字段 avatar和favicon， 值设置成头像的链接地址。我一般把图片放在hexo根目录的source文件夹下自己创建的image文件夹中。 设置侧边栏社交链接和推荐链接打开主题配置文件（_config.yml）搜索social_icons:,在fontawesome官网找喜欢的小图标，将名字复制在如下位置。搜索links：，在这里可以添加推荐阅读的链接，如下图 next进阶 网站底部加上访问量 打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话 然后再合适的位置添加显示统计的代码123456&lt;div class="powered-by"&gt; &lt;i class="fa fa-user-md"&gt;&lt;/i&gt; &lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 uv的方式，单个用户连续点击n篇文章，只记录1次访客数注意这个东西在本地服务器上的数据都是假的，只有线上服务器才是真实数据。引入网易云音乐 我们可以通过网易云提供的外链播放器，让自己的博客自动播放音乐。将下面的代码复制到自己想要放置播放器的地方 这个播放器可以放在任何地方。我选择放在侧边栏中。1234&lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66"&gt; &lt;/iframe&gt;&lt;/div&gt; 注意 这里复制下来的地址中src是没有https:的 需要自己添加，不然无法生成播放器，这个坑我爬了一个晚上… 实现统计功能使用hexo-wordcount插件，实现博客字数和阅读时间的统计在hexo根目录下执行下列命令，安装插件 npm install hexo-wordcount –save 然后在主题配置文件中找到post_wordcount，将需要的东西改成true，即可实现该功能。 阅读次数统计我是使用leancloud来实现阅读次数的统计。首先需要去leancloud官网注册一下注册完成后，进入控制台，点击箭头指向的东西在存储中创建一个类 Counter 必须是这个命名然后获取appid和appkey将这两个值放到主题配置文件中leancloud_visitors下对应的字段1234leancloud_visitors: enable: true app_id: yourapp_id app_key: yourapp_key 最后在安全中心中，设置Web 安全域名同样这个数据在本地是无法计算的，而且会报错，只有上线后才能计算每次浏览的次数。 设置评论功能网上有一大堆开源的评论插件，类似来必力(韩国棒子出品，这不抵制一下？）、畅言、友言。最后发现上面一个leancloud也可以用来做评论，只不过需要配合Valine一起使用。 下载最新的Valine.min.js核心代码库到本地 将下载好的 Valine.min.js 放置于 next\source\js\src\下 打开valine配置文件进行配置,valine配置文件路径：next\layout\_third-party\comments\valine.swig if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;123456789101112131415161718192021222324252627282930313233343536 &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unjkp.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt; //删除Valine核心代码库外链调用 &lt;script src=&quot;/js/src/Valine.min.js&quot;&gt;&lt;/script&gt; //调用刚下载的本地文件以加速加载速度 &#123;% set valine_uri = &apos;/js/src/Valine.min.js&apos; %&#125; //这里改为从本地加载 &#123;% if theme.vendors.valine %&#125; &#123;% set valine_uri = theme.vendors.valine %&#125; &#123;% endif %&#125; &lt;script src=&quot;&#123;&#123; valine_uri &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var GUEST = [&apos;nick&apos;,&apos;mail&apos;,&apos;link&apos;]; var guest = &apos;&#123;&#123; theme.valine.guest_info &#125;&#125;&apos;; guest = guest.split(&apos;,&apos;).filter(function (item) &#123; return GUEST.indexOf(item)&gt;-1; &#125;); new Valine(&#123; el: &apos;#comments&apos; , verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;, appKey: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;, placeholder: &apos;&#123;&#123; theme.valine.placeholder &#125;&#125;&apos;, avatar:&apos;&#123;&#123; theme.valine.avatar &#125;&#125;&apos;, guest_info:[&apos;nick&apos;] , //评论者只需要提供评论的昵称即可 pageSize:&apos;&#123;&#123; theme.valine.pageSize &#125;&#125;&apos; || 10, &#125;); //增加以下六行代码去除 power by valine var infoEle = document.querySelector(&apos;#comments .info&apos;); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; 然后去主题配置文件中进行修改，下面是我的配置 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true //打开valine评论功能 appid: 你的leancloud appid appkey: 你的leancloud appkey notify: false //邮件提醒 verify: true //评论时是否有验证码，需要在Leancloud 设置-&gt;安全中心 中打开 placeholder: 说点什么吧！ //评论框默认显示 avatar: hide //评论者的头像,我这里设置的不显示 guest_info: nick # custom comment header pageSize: 10 # pagination size 下面是效果图 为博客加上萌萌的宠物这个也是在找资料的时候发现的，虽然很好看，但是跟那个canvas背景图一样，有点占资源，可能会导致网站打开有点慢。下面是设置方法。 在hexo根目录下安装插件 npm install -save hexo-helper-live2d 宠物样式列表，选择你喜欢的萌妹子或者小动物，然后安装。 npm install live2d-widget-model-“宠物代码” 在hexo的配置文件中添加下列配置1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-z16 display: position: right width: 100 height: 150 mobile: show: true 我这个在本地运行好像不是很流畅，建议把mobile设置为false，因为手机上真的好占位置。。。下面是效果图别问我为啥选这个，老子晕奶！！！ 好了，暂时写这么多吧，感觉还有好多坑没有写进来。写完了还是蛮有成就感的，至少对得起掉下的这么多头发了。。。]]></content>
      <categories>
        <category>Hexo 搭建博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建属于自己的博客（一）]]></title>
    <url>%2F2018%2F09%2F30%2F%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近心血来潮，突然想搞一个自己的博客，虽然很早之前按就在博客园上注册过，总感觉有那么一丢丢low。网上查了查，发现Wordpressh和Hexo都还行，都支持安装自定义主题。Wordpress需要本地的数据库和支持后台操作，相比较下Hexo更加轻量级，那就这么愉快的决定了，let’s get it！ 准备工作 安装Node.js和配置好Node.js环境。 安装Git和配置好Git环境。 申请github账号，后面需要将项目上传至github上，使用它的服务器上线。 安装Hexo 全局安装Hexo，在自己认为合适的地方创个文件夹，在这个文件夹目录下打开命令行，执行下列代码。 1npm install hexo -g 检查hexo是否安装成功，如果出入一大堆版本号，就是成功了。 1hexo -v 在该文件夹下初始化hexo 1hexo init 看到后面的“Start blogging with Hexo！”，就代表成功咧，激不激动噻！ 安装hexo运行所需要的组建，建议在网络好的情况下进行，不然丢包出错真的不好查。。。 1npm install 编辑静态文件，手不要贱，等着就行。 1hexo g 启动hexo本地服务器，根据提示在浏览器中输入网址。 1hexo s 如果端口号被占用，执行下列代码1hexo server -p 端口号 如果出现下图就代表成功了 关联github 确保自己使用的电脑已经有生成公钥和密钥，并且在github上已经设置好。测试连接代码如下。 1ssh -T git@github.com 在github上创建一个新的仓库，项目必须要遵守格式：账户名.github.io，不然不能使用它本身提供的服务器。 配置Deployment,在根目录下找到_config.yml文件,修改deploy，一般在文件的最后面。repository后面改成自己仓库的SSH链接地址。 1234deploy: type: git repository: git@github.com:hzy1735/hzy1735.github.io.git branch: master 安装一个模块，用来进行自动打包提交。 1npm install hexo-deployer-git --save 制定打包提交命令 1hexo d -g 如果没有error，就是部署成功了，输入http://用户名.github.io，即可浏览自己的博客了 编写博客 在根目录下，命令行中输入下列代码，自动创建一个后缀为md的文件 1hexo new post “博客名” 由于Hexo的博客都是md文件，所以需要学一下md的语法，其实很简单，自行百度去吧。我是用vscode编写的，安装一个Markdown Preview Enhanced插件，就可以预览写出来的东西，vscode真牛逼！！！ 编写完成后，在执行打包提交代码，就能对线上的博客进行更新了。1hexo d -g 以上就是安装hexo和上线的操作咯，接下来还有更高级的操作咧。]]></content>
      <categories>
        <category>Hexo 搭建博客</category>
      </categories>
  </entry>
</search>
