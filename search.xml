<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue为什么不能监听通过下标修改数组的变化]]></title>
    <url>%2F2018%2F12%2F07%2FVue%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%91%E5%90%AC%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我们知道在 Vue 中的数据是通过 Object.defineProperty 这种劫持的方式来实现数据更新的，可是数组是一个比较特殊的类型。在项目中直接通过下标修改数组，vue 并不能监听到相应的变化，页面不能实现实时渲染。在官网上给出的解释： 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength &emsp;&emsp;对于这个说法还是太笼统，没有什么可观性，话不多说直接上源码。在 vue 的源码中有这么一段代码，实现了数据的监听绑定。Observer 可以将一个 plainObject 或者 array 变成 reactive 的。代码很少，就是遍历 plainObject 或者 array，对每一个键值调用 defineReactive 方法。 12345678910111213141516171819202122232425262728293031323334353637//观察者类被绑定到每一个观察对象，一旦绑定，这个观察者使目标对象的属性键转换到getter/setter方法，收集依赖和发送的更新var Observer = function Observer (value) &#123; this.value = value; this.dep = new Dep(); this.vmCount = 0; def(value, '__ob__', this); if (Array.isArray(value)) &#123; var augment = hasProto ? protoAugment : copyAugment; augment(value, arrayMethods, arrayKeys); this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;;/** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */Observer.prototype.walk = function walk (obj) &#123; var keys = Object.keys(obj); for (var i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]); &#125;&#125;;/** * Observe a list of Array items. */Observer.prototype.observeArray = function observeArray (items) &#123; for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]); &#125;&#125;; 当这个变量不为数组的时候，执行walk()方法，遍历变量中的 key，调用了defineReactive()，这个就是实现了传说中的双向数据绑定。 当这个变量为数组的时候，判断是否存在proto，如果存在的话直接把他的原型链拷贝过来，如果不存在的话，手动遍历，然后监听这些变量。下面是这两个方法在源码中的实现。 123456789101112131415161718192021/** * Augment an target Object or Array by intercepting * the prototype chain using __proto__ */function protoAugment (target, src, keys) &#123; /* eslint-disable no-proto */ target.__proto__ = src; /* eslint-enable no-proto */&#125;/** * Augment an target Object or Array by defining * hidden properties. *//* istanbul ignore next */function copyAugment (target, src, keys) &#123; for (var i = 0, l = keys.length; i &lt; l; i++) &#123; var key = keys[i]; def(target, key, src[key]); &#125;&#125; 理清楚源码的机理后，我突然有一个大胆的想法，这个是尤雨溪大大和他的团队做了内部的处理，强制不让我们通过这个方法通过下边修改数组，不好意思，在下铁头功，就是想要试一试，二话不说就把源码改了。 1234567891011121314151617var Observer = function Observer (value) &#123; this.value = value; this.dep = new Dep(); this.vmCount = 0; def(value, '__ob__', this); if (Array.isArray(value)) &#123; // 就是这么任性，我不管，我就要通过下标实现修改。 // var augment = hasProto // ? protoAugment // : copyAugment; // augment(value, arrayMethods, arrayKeys); // this.observeArray(value); this.walk(value); &#125; else &#123; this.walk(value); &#125;&#125;; 顺便在 defindeReactive 中加上获取值和修改值的语句，方便观察 123456789101112131415161718192021222324252627282930313233343536373839Object.defineProperty(obj, key, &#123;enumerable: true,configurable: true,get: function reactiveGetter () &#123; //添加get的显示信息 console.log('get') var value = getter ? getter.call(obj) : val; if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value&#125;,set: function reactiveSetter (newVal) &#123; //添加set的显示信息 console.log('set') var value = getter ? getter.call(obj) : val; /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if ("development" !== 'production' &amp;&amp; customSetter) &#123; customSetter(); &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); dep.notify();&#125;&#125;); 然后直接写了一个简单的demo，运行结果，渲染的时候确实监听到了get方法。至于为啥遍历了两边，每次都出现2次，还没在源码中找到解释，这个问题找到了再说吧。接下来点击每个数字，触发对应的方法。卧槽，竟然实现了双向绑定，不可思议了,也就是说js语法功能并不会限制数组的监测。有了上面的实验，我的结论是数组在vue中是可以实现响应式更新的，但是不明白尤大是出于什么考虑，没有加入这一功能。网上找了一下这方面的信息，有个big old和尤大成功对话，并且尤大给出解释。好吧，果然官方…其实官方也是提供了一些变异方法更新数组，也会触发视图的更新。 push() pop() shift() unshift() splice() sort() reverse() 都是一些数组原始的方法，但是自己做了封装，增加了一些自己的实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 获取原生Array中提供的所有方法var arrayProto = Array.prototype;// 将原生提供的方法创建一个新的对象，以免修改原生的方法，造成全局污染var arrayMethods = Object.create(arrayProto);// 将要实现的几个变异方法var methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];/** * Intercept mutating methods and emit events * 截取这些方法，然后实现相应的操作 */methodsToPatch.forEach(function (method) &#123; // cache original method 缓存原始方法 var original = arrayProto[method]; //def即Object.defineProperty的包装函数 def(arrayMethods, method, function mutator () &#123; var args = [], len = arguments.length; while ( len-- ) args[ len ] = arguments[ len ]; // 调用原始方法完成对数组的更新 var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case 'push': case 'unshift': inserted = args; break case 'splice': inserted = args.slice(2); break &#125; // 如果有修改的数据，则添加observer监听器 if (inserted) &#123; ob.observeArray(inserted); &#125; // notify change 触发更新 ob.dep.notify(); return result &#125;);&#125;); &emsp;&emsp;其实做完上面的一些骚操作，只得到一个性能原因的解答，还是一脸蒙蔽。毕竟对于大量数组，循环遍历可能会消耗一些时间，如果这个时间不能够承受的话，那就选择废弃吧。&emsp;&emsp;vue看起来简单，其实套路还是多啊。扶我起来，我还能学！ 下面提供一些源码解读的思路：详细描述Vue的数据响应系统Vue的数组变动]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter简介及环境配置]]></title>
    <url>%2F2018%2F12%2F05%2FFlutter%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;号外！号外！在昨晚的 Flutter Live 2018 上，Google 宣布 Flutter 1.0 正式发布。今天早上一起来看见这个信息，卧槽又要开始学一门新的开发技术了。&emsp;&emsp;从我们首次看到 Flutter 的 Beta 测试版，到如今的 1.0 正式版，总共经过了 9个多月。 2 月底在世界移动大会 (MWC) 上发布首个 Beta 版; 5 月的 Google I/O 大会上发布 Beta 3 ; 6 月底的 GMTC 发布首个预览版； 9 月的谷歌者大会上，发布预览版 2； 12月初的 Flutter Live 2018 上，发布1.0 稳定版。 &emsp;&emsp;Flutter 1.0 主要聚焦于稳定性和 bug 修复，同时还包含两项新功能的预览 —— Add to App 和 platform views。 &emsp;&emsp;铺垫了这么多，可能有些同学还是不知道Flutter到底是个什么玩意。下面就是敲黑板划重点的时候了。&emsp;&emsp;Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。配合Dart语言和Flutter的热重载，可帮助您快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以在亚秒内重载，并且不会丢失状态。 现在就试试Flutter，入门很简单！Flutter官网 开发环境配置 获取Flutter SDK 去flutter官网下载其最新可用的安装包点击下载 直接在github上下载 git clone -b master https://github.com/flutter/flutter.git 将安装包zip解压到你想安装Flutter SDK的路径（如：C:\src\flutter；注意，不要将flutter安装到需要一些高权限的路径如C:\Program Files\）。 配置flutter的环境变量，讲flutter的bin文件夹的绝对路径配置到path中，在命令行中执行flutter-h ，如果出现下图，安装成功。 安装JDK 如果没有搭过JAVA环境的同学看一下，之前搭过的直接看下一步。 去oracle网站下载就okJDK下载 下载完成后直接安装，中途会安装jre，记住自己安装的路径。 安装完成后配置环境变量。新建环境变量JAVA_HOME，将jdk文件夹的路径配上去在Path后新增两天属性，将jdk文件夹中的bin 和bin下的jre路径配上。 在命令行中输入java -version，出现下面的东西就是成功了。 安装Android Studio 开发环境需要Android Studio的一些配置，直接去官网下载即可。注意安装的时候不要有中文路径和空格，会报莫名奇妙的错！ 第一次启动Android Studio,会出现下图，点去cancel，进入下载依赖的环节，这时候需要科学上网，否则安装速度贼慢，网上工具多的是，干就玩事了。 下载完成后，找到下图的选项，下载两个插件，Flutter和Dart 连接调试设备 可以使用真机测试 可以去网上安装一些安卓模拟器，低配版雷电安卓模拟器,简单无脑，专业版Genymotion，需要一些配置，这里就不赘述了。 最后执行下列命令，检测环境是否符合条件 flutter doctor 如果出现下面的命令，ok可以进行最后一步了。 创建项目，启动flutter！ 执行创建项目的命令 flutter create 你的项目名cd 项目名flutter run 有些人第一次编译可能会很快，有些人运气不大好，可能慢很多成功截图 模拟器上的截图 配置环境中遇到的问题 创建项目卡在第一步，一直不会动 解决办法：需要配置两个环境变量，设置一下源。 在用户变量中创建PUB_HOSTED_URL ，值为https://pub.flutter-io.cn 在用户变量中创建FLUTTER_STORAGE_BASE_URL，值为https://storage.flutter-io.cn Android SDK下载慢解决办法：可以先去百度云盘或者某些网站下载一个，这样进行外网安装的时候，可以减少一点时间。 总结&emsp;&emsp;总的来说搭建这个环境还是蛮简单的，前提是有一个稳定的网，今天的网真的是无语了，安装sdk直接retry三次。接下来就是看官网文档，学习这些新的部件和语法了。对于mac电脑的配置等我有了mac再说吧，太真实了。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听我吹逼之Redux 源码解读（一）]]></title>
    <url>%2F2018%2F12%2F02%2FRedux%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Redux 是 JavaScript 状态容器，提供可预测化的状态管理。不仅可以让你构建一致化的应用，还提供超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。 不管你有没有使用过它们，只需几分钟就能上手 Redux。&emsp;&emsp;但是就是这么个玩意，源代码竟然只有短短600行，今天就带你一层一层褪去她的衣物，满足你最原始的冲动。系好安全带，老司机要发车了！！！ 入口文件解读&emsp;&emsp;看源码最简单的方式，就是从入口文件来看，看它依赖哪些模块，然后在依次看这些模块的内容，最后也就对整个代码有个清晰的认识了。 12345678910111213141516171819202122232425262728293031323334353637import createStore from './createStore'import combineReducers from './combineReducers'import bindActionCreators from './bindActionCreators'import applyMiddleware from './applyMiddleware'import compose from './compose'import warning from './utils/warning'import __DO_NOT_USE__ActionTypes from './utils/actionTypes'/* * This is a dummy function to check if the function name has been altered by minification. * If the function has been minified and NODE_ENV !== 'production', warn the user. */// 就是根据 isCrushed 是否被压缩了，来警告开发者正在非生产环境使用一个压缩过的代码。function isCrushed() &#123;&#125;if ( process.env.NODE_ENV !== 'production' &amp;&amp; typeof isCrushed.name === 'string' &amp;&amp; isCrushed.name !== 'isCrushed') &#123; warning( 'You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.' )&#125;export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes&#125; 很明显这个入口文件就是将这些模块引入后然后直接暴露出去。整个Redux就是依赖这些模块，其中几个也是老面孔了。 createStore combineReducers bindActionCreators applyMiddleware compose warning createStore这个模块每次都在使用，用来创建整个应用的store。 import { createStore } from ‘redux’let store = createStore(reducers) 这个模块依赖的都是一些工具函数12import ActionTypes from './utils/actionTypes'import isPlainObject from './utils/isPlainObject' ActionTypes的源码主要生成一个随机字符串，用来初始化每个reducer的命名1234567891011121314const randomString = () =&gt; Math.random() .toString(36) .substring(7) .split('') .join('.')const ActionTypes = &#123; INIT: `@@redux/INIT$&#123;randomString()&#125;`, REPLACE: `@@redux/REPLACE$&#123;randomString()&#125;`, PROBE_UNKNOWN_ACTION: () =&gt; `@@redux/PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;`&#125;export default ActionTypes isPlainObject的源码主要用来判断是否为一个字面量的对象，用来判断state是否有效。12345678910export default function isPlainObject(obj) &#123; if (typeof obj !== 'object' || obj === null) return false let proto = obj while (Object.getPrototypeOf(proto) !== null) &#123; proto = Object.getPrototypeOf(proto) &#125; return Object.getPrototypeOf(obj) === proto&#125; createStore的源码主要实现了5个方法 12345678910111213141516171819202122232425262728293031323334353637383940export default function createStore(reducer, preloadedState, enhancer) &#123; if ( (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'function') || (typeof enhancer === 'function' &amp;&amp; typeof arguments[3] === 'function') ) &#123; throw new Error( 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function' ) &#125; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; //somethings return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 参数： reducer： reducer必须是一个function类型，此方法根据action.type更新state preloadedState： store tree初始值 enhancer： enhancer通过添加middleware，增强store功能 实现方法 dispatch：分发action subscribe：注册listener，监听state变化 getState：读取store tree中所有state replaceReucer：替换reducer，改变state更新逻辑 [$$observable] 让变量可观察。一般情况下用不到，用到了我也不背锅哦 第一个 if 语句的意思就是说，如果只传入了两个参数，且第二个参数 preloadedState 为函数，那么就认为第二个参数为 enhancer . 第二个 if 语句确保 enhancer 是一个函数，并且当 enhancer 作为参数传入的时候，返回 enhancer(createStore)(reucer, preloadedState) 作为 createStore 的返回，也就是我们要的 store. 第三个 if 语句确保 reducer 是一个函数。 接下来解读每个方法的具体实现。 getState 1234567891011function getState() &#123; if (isDispatching) &#123; throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) &#125; return currentState &#125; 这个函数可以获取当前的状态，createStore 中的 currentState 储存当前的状态树，这是一个闭包，这个参数会持久存在，并且所有的操作状态都是改变这个引用，getState 函数返回当前的 currentState。如果当前状态不存在，可能是没有返回初始化的state，会报错。 subscribe 1234567891011121314151617181920212223242526272829303132333435363738function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.' ) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125;&#125; 这里我省略了一堆注释，其实那一大段注释已经说的很明显了，注册一个 listener 监听函数，把他 push 到当前的监听里列表 nextListener 里面，并返回一个 unsubscribe 方法用来注销当前这个监听函数。之前版本还没有执行的时候销毁会报错，现在已经修改了。 dispatch 12345678910111213141516171819202122232425262728293031323334function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action&#125; dispatch用来分发一个 action 来改变当前的 state . 也是唯一的改变 state 的方法。接受一个用来描述动作的 action 为参数，并且把这个 action 作为函数的返回值。从代码前面的判断可以看到，action 必须是一个字面量对象，并且必须包含一个 type 的属性。 当isDispatching为真的时候开始触发函数，这里的 currentReducer 是一个函数，他接受两个参数：当前状态 和 action，然后返回计算出来的新的状态；然后遍历 nextListeners 列表，调用每个监听函数； replaceReducer 12345678function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;)&#125; 这个函数可以替换 store 当前的 reducer 函数，首先直接把 currentReducer = nextReducer，直接替换；然后 dispatch({ type: ActionTypes.INIT }) ，用来初始化替换后 reducer 生成的初始化状态并且赋予 store 的状态； observable 1234567891011121314151617181920212223242526272829303132function observable() &#123; const outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== 'object' || observer === null) &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125;&#125; 对于这个函数，是不直接暴露给开发者的，它提供了给其他观察者模式／响应式库的交互操作，具体可看https://github.com/zenparsing/es-observable 最后执行 dispatch({ type: ActionTypes.INIT })，用来根据 reducer 初始化 store 的状态。 combineReducers这个模块用来合并多个 reducers 到一个 reducer,一般我们会在store的reducers.js文件夹合并reducer12345678910111213import &#123; combineReducers &#125; from 'redux'import &#123; reducer as home &#125; from 'pages/home'import &#123; reducer as news &#125; from 'pages/news'import &#123; reducer as cart &#125; from 'pages/cart'import &#123; reducer as shop &#125; from 'pages/shop'export default combineReducers(&#123; home, news, cart, shop&#125;) 这个模块中主要实现了三个方法 getUndefinedStateErrorMessage听他的名字就知道了 获得未定义状态的错误信息1234567891011function getUndefinedStateErrorMessage(key, action) &#123; const actionType = action &amp;&amp; action.type const actionDescription = (actionType &amp;&amp; `action "$&#123;String(actionType)&#125;"`) || 'an action' return ( `Given $&#123;actionDescription&#125;, reducer "$&#123;key&#125;" returned undefined. ` + `To ignore an action, you must explicitly return the previous state. ` + `If you want this reducer to hold no value, you can return null instead of undefined.` )&#125;getUnexpectedStateShapeWarningMessage 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function getUnexpectedStateShapeWarningMessage( inputState, reducers, action, unexpectedKeyCache) &#123; const reducerKeys = Object.keys(reducers) const argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer' if (reducerKeys.length === 0) &#123; return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ) &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of "` + &#123;&#125;.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + `". Expected argument to be an object with the following ` + `keys: "$&#123;reducerKeys.join('", "')&#125;"` ) &#125; const unexpectedKeys = Object.keys(inputState).filter( key =&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key] ) unexpectedKeys.forEach(key =&gt; &#123; unexpectedKeyCache[key] = true &#125;) if (action &amp;&amp; action.type === ActionTypes.REPLACE) return if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? 'keys' : 'key'&#125; ` + `"$&#123;unexpectedKeys.join('", "')&#125;" found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `"$&#123;reducerKeys.join('", "')&#125;". Unexpected keys will be ignored.` ) &#125;&#125; 这个更长的名字更好理解了 获得不期望的状态类型警告报告,说明输入的state就不是一个字面量对象或者结构不对。且inputState 的 key 都应该在 reducer 的自身属性（OwnProperty, 非原型链上的）中，并且不能在传入的 unexpectedKeyCache 中。 assertReducerShape 123456789101112131415161718192021222324252627282930313233function assertReducerShape(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; const reducer = reducers[key] const initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;) if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) &#125; if ( typeof reducer(undefined, &#123; type: ActionTypes.PROBE_UNKNOWN_ACTION() &#125;) === 'undefined' ) &#123; throw new Error( `Reducer "$&#123;key&#125;" returned undefined when probed with a random type. ` + `Don't try to handle $&#123; ActionTypes.INIT &#125; or other actions in "redux/*" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) &#125; &#125;)&#125; 用来保证传入的 reducers 的结构正确，也就说说每个 reducer 都必须在收到 INIT action 后返回一个不为 undefined 的 initState ，并且这个 action 不能在 reducer 中专门去处理。这也是为什么我们在 reducer 里面一定要指定默认返回的 state 的原因. combineReducers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263export default function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key "$&#123;key&#125;"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) let unexpectedKeyCache if (process.env.NODE_ENV !== 'production') &#123; unexpectedKeyCache = &#123;&#125; &#125; let shapeAssertionError try &#123; assertReducerShape(finalReducers) &#125; catch (e) &#123; shapeAssertionError = e &#125; return function combination(state = &#123;&#125;, action) &#123; if (shapeAssertionError) &#123; throw shapeAssertionError &#125; if (process.env.NODE_ENV !== 'production') &#123; const warningMessage = getUnexpectedStateShapeWarningMessage( state, finalReducers, action, unexpectedKeyCache ) if (warningMessage) &#123; warning(warningMessage) &#125; &#125; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125; combineReducer 接收一个用来合并成一个 reducer 的对象，执行后返回一个函数，也即是我们的 rootReducer . 首先把传入的 reducers 按 key 遍历后赋值给 finalReducers . 然后进行一堆错误判断，最后返回一个函数 combination. 也就是合并后的 reducer . 总结&emsp;&emsp;今天先看着两个，卧槽，看源码太烧脑了，我为什么要装这个逼，头发都掉没了， 先去搞点腰子补一补，撤了，后面的代码未完待续~]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable 常用方法]]></title>
    <url>%2F2018%2F12%2F02%2FImmutable%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这里主要整理一下项目中用到的 Immutable 相关方法，第一次使用可能有点生疏，还是需要对照文档。但是部分方法确实高效，封装了原生 JS 的方法，同时也集成了 lodash 的一些方法。 Immutable 官网文档 Immutable 常见数据类型 List: 有序索引集，类似 JavaScript 中的 Array。 Map: 无序索引集，类似 JavaScript 中的 Object。 Seq: 序列，但是可能不能由具体的数据结构支持。 OrderedMap: 有序的 Map，根据数据的 set()进行排序。 Set: 没有重复值的集合。 OrderedSet: 有序的 Set，根据数据的 add 进行排序。 Stack: 有序集合，支持使用 unshift（）和 shift（）添加和删除。 Range(): 返回一个 Seq.Indexed 类型的集合，这个方法有三个参数，start 表示开始值，默认值为 0，end 表示结束值，默认为无穷大，step 代表每次增大的数值，默认为 1.如果 start = end,则返回空集合。 Repeat(): 返回一个 vSeq.Indexe 类型的集合，这个方法有两个参数，value 代表需要重复的值，times 代表要重复的次数，默认为无穷大。 Record: 一个用于生成 Record 实例的类。类似于 JavaScript 的 Object，但是只接收特定字符串为 key，具有默认值。 Collection: 是构建所有数据结构的基类，不可以直接构建。 常用API fromJS() 作用：将一个 js 数据转换为 Immutable 类型的数据。用法：fromJS(value, converter)简介：将一个对象自动转化成 Map，将一个数组自动转换成 List，只能实现一层的转化 12345const defaultState = fromJS(&#123; total: 0, pay: false, selectAll: false&#125;) toJS() 作用：将一个 Immutable 数据转换为 JS 类型的数据。用法：value.toJS()简介：将一个 Map 自动转化成对象，将一个 List 自动转换成数组，只能实现一层的转化 is() equals() 作用：对两个对象进行比较。用法：is(map1,map2) map1.equals(map2)简介：返回值为一个 Boolean，和原生 JS 比较不同的是，这个比较的是两个对象的存储地址，就算值相同，存储地址不同，返回值也是 false ，可以用 ‘===’实现相同功能 123456const map1 = Map(&#123; a: 1, b: 2, c: 3&#125;)const map2 = Map(&#123; a: 1, b: 2, c: 3&#125;)console.log(map1.equals(map2)) // trueconsole.log(map1 == map2) // falseconsole.log(map1 === map2) // falseconsole.log(is(map1, map2) // true List Map 作用：创建 Immutable 的 List 和 Map 对象用法：List() Map() get() getIn() 作用：获取对象的具体值。用法：get(index: number): T | undefinedgetIn(searchKeyPath: Iterable, notSetValue?: any): any简介：get()只能查找一层的 List 或者 Map，getIn()可以对多层的 List 或者 Map 进行取值，需要用数组的方法输入路径。 12345const nested = fromJS(&#123; a: &#123; b: &#123; c: [ 3, 4, 5 ] &#125; &#125; &#125;)console.log(nested.get('a'))//Map &#123; "b": Map &#123; "c": List [ 3, 4, 5 ] &#125; &#125;console.log(nested.getIn([ 'a', 'b', 'c' , 0 ]))//3 set() setIn() 作用：设置对象的具体值。用法：set(index: number, value: T): ListsetIn(keyPath: Iterable, value: any): this简介：同上12345const nested = fromJS(&#123; a: &#123; b: &#123; c: [ 3, 4, 5 ] &#125; &#125; &#125;)console.log(nested.set('a',1))//Map &#123; "a" :1 &#125;console.log(nested.getIn([ 'a', 'b', 'c' , 0 ]),0)// Map &#123; "a": Map &#123; "b": Map &#123; "c": List [ 0, 4, 5 ] &#125; &#125; &#125; updateIn() 作用：更新对象的具体值。用法：updateIn(keyPath: Iterable,notSetValue: any,updater: (value: any) =&gt; any): thisupdateIn(keyPath: Iterable, updater: (value: any) =&gt; any): this简介：更新相关对象，回调函数中处理后返回一个新的状态。1let newProducts1 = state.updateIn(['products'], list =&gt; list.push(1)) delete() deleteIn() 作用：删除数组中的值或者对象的属性。用法：delete(index: number): Listdelete(key: K): thisdeleteIn(keyPath: Iterable): this12list.delete(1);list.deleteIn([0,1]); groupBy() 作用：对数据进行分组12345678910111213const listOfMaps = List([ Map(&#123; v: 0 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 0 &#125;), Map(&#123; v: 2 &#125;)])const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))// Map &#123;// 0: List [ Map&#123; "v": 0 &#125;, Map &#123; "v": 0 &#125; ],// 1: List [ Map&#123; "v": 1 &#125;, Map &#123; "v": 1 &#125; ],// 2: List [ Map&#123; "v": 2 &#125; ],// &#125; indexOf() lastIndexOf() 作用：和js数组中的方法相同，查找第一个或者最后一个value的index值，找不到则返回-1简介：Map不存在此方法 findIndex() findLastIndex() 作用：查找满足要求的元素的index值简介：Map不存在此方法 Seq() 作用：将集合转化成seq123const &#123; Map &#125; = require('immutable')const map = Map(&#123; a: 1, b: 2, c: 3 &#125;const lazySeq = Seq(map) Seq 允许有效链接操作，允许表达逻辑12345lazySeq .flip() .map(key =&gt; key.toUpperCase()) .flip()// Seq &#123; A: 1, B: 1, C: 1 &#125; 总结&emsp;&emsp;总体来说，Immutable的用法并没有这么繁琐，只要在使用的时候保持清醒的头脑，永远记住操作完返回一个新的状态久好了。其他一些零零碎碎的方法反正和原生JS类似啦，骚年，征服Immutable这个小妖精变得so easy!!!]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何在React-Native上使用Typescript]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%A6%82%E4%BD%95%E5%9C%A8React-Native%E4%B8%8A%E4%BD%BF%E7%94%A8Typescript%2F</url>
    <content type="text"><![CDATA[创建React-Native项目 安装脚手架 yarn global add create-react-native-app 创建项目 create-react-native-app 项目名称 进入项目并启动 cd xxxyarn start 如果不使用Typescript，现在就可以经行RN的项目开发了，但是要使用Typescript，还需要折腾一番。 配置Typescript开发依赖 安装ts依赖 这里安装ts语言依赖，同时将react的一些包安装到 @types文件夹内，不然写react代码的时候会报找不到react包依赖 yarn add typescript tslint -Dyarn add @types/react @types/react-native @types/react-dom -D 我们还需要concurrently来实时监听文件变化，rimraf，并发地清理从ts编译过来的js文件的输出文件夹，并发地运行npm脚本. yarn add concurrently rimraf -D 配置ts文件 在根目录下手动创建tsconfig.json文件，将下面的代码直接复制进去123456789101112131415161718192021222324252627282930313233343536373839&#123; "compilerOptions": &#123; "module":"es2015", "target": "es2015", "jsx": "react", "rootDir": "src", "outDir": "build", "allowSyntheticDefaultImports": true, "noImplicitAny": true, "sourceMap": true, "experimentalDecorators": true, "preserveConstEnums": true, "allowJs": true, "noUnusedLocals": true, "noUnusedParameters": true, "noImplicitReturns": true, "skipLibCheck": true, "moduleResolution":"Node" &#125;, "filesGlob": [ "typings/index.d.ts", "src/**/*.ts", "src/**/*.tsx", "node_modules/typescript/lib/lib.es6.d.ts" ], "types": [ "react", "react-dom", "react-native" ], "exclude":[ "build", "node_modules", "jest.config.js", "App.js" ], "compileOnSave": false&#125; 需要注意一些细节： 我们希望将Typescript应用程序的所有代码存储在src文件夹下的文件夹/子文件夹中。用“rootDir”:“src“，确保你的根目录为src或者也可以手动更改 并把babel.config.js文件扔到这个文件夹内 安装npm脚本的依赖，方便打包和运行 yarn add react-native-scripts 将package.json中的scripts代替为下面的配置123456789101112131415161718'script':&#123; "start": "react-native-scripts start", "eject": "react-native-scripts eject", "android": "react-native-scripts android", "ios": "react-native-scripts ios", "test": "node node_modules/jest/bin/jest.js", "lint": "tslint src/**/*.ts", "tsc": "tsc", "clean": "rimraf build", "build": "yarn run clean &amp;&amp; yarn run tsc --", "watch": "yarn run build -- -w", "watchAndRunAndroid": "concurrently \"yarn run watch\" \"yarn run android\"", "buildRunAndroid": "yarn run build &amp;&amp; yarn run watchAndRunAndroid ", "watchAndRunIOS": "concurrently \"yarn run watch\" \"yarn run ios\"", "buildRunIOS": "yarn run build &amp;&amp; yarn run watchAndRunIOS ", "watchAndStart": "concurrently \"yarn run watch\" \"yarn run start\"", "buildAndStart": "yarn run build &amp;&amp; yarn run watchAndStart "&#125; 将main更改为： “main”:”./node_modules/react-nativescripts/build/bin/crna-entry.js” 这意味着我们的应用程序从这个crna-entry.js 开始。打开这个文件，你会发现它引用了我们的App.js var _App = require(‘../../../../App’); 修改App.js文件 12import App from './build/App';export default App; 注意创建typescript文件后缀为.tsx 启动任务 运行命令即可,直接打包并且启动任务，这可能需要一些事件，少侠请耐心等候。 yarn buildAndStart]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable.js之我见]]></title>
    <url>%2F2018%2F11%2F30%2FImmutable.js%E4%B9%8B%E6%88%91%E8%A7%81%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;本文主要介绍facebook推出的一个类库immutable.js，以及如何将immutable.js集成到我现有的react+redux架构的移动端项目中。 一.immutable.js介绍 原生js在redux中处理数据的坑&emsp;&emsp;前两天在处理购物车的redux逻辑的时候，遇到一个问题，全选反选的功能和逻辑没有问题，改变后的数据在reducer中打印出来也已经是正确的改变，但是页面中的元素就是不会发生改变，甚至不会重新执行render()的生命周期。123456789101112131415161718//获取存储的购物车商品信息let products = state.products//根据传入的id 查找并修改这个物品的选中状态for (let i = 0; i &lt; products.length; i++) &#123; if (products[i].id === action.id) &#123; products[i].select = action.isSelect break; &#125; else &#123; continue &#125;&#125;//返回新的状态return &#123; ...state, products,&#125;&emsp;&emsp;乍一看好像没有问题，找了好久才发现在reducer中处理数据的时候使用了地址引用，导致返回的还是原来的对象，状态没有发生改变。React对于状态变化的感知是必须返回的新对象才会引起状态的变化，从而去渲染页面。下面才是正常的代码。12//获取存储的购物车商品信息let products = state.products&emsp;&emsp;在js中，引用类型的数据，优点在于频繁的操作数据都是在原对象的基础上修改，不会创建新对象，从而可以有效的利用内存，不会浪费内存，这种特性称为mutable（可变），但恰恰它的优点也是它的缺点，太过于灵活多变在复杂数据的场景下也造成了它的不可控性，假设一个对象在多处用到，在某一处不小心修改了数据，其他地方很难预见到数据是如何改变的，针对这种问题的解决方法，一般就像刚才的例子，会想复制一个新对象，再在新对象上做修改，这无疑会造成更多的性能问题以及内存浪费。 为了解决这种问题，出现了immutable对象，每次修改immutable对象都会创建一个新的不可变对象，而老的对象不会改变。immutable.js介绍immutable.js主要有三大特性： Persistent data structure （持久化数据结构） 一般听到持久化，在编程中第一反应应该是，数据存在某个地方，需要用到的时候就能从这个地方拿出来直接使用 但这里说的持久化是另一个意思，用来描述一种数据结构，一般函数式编程中非常常见，指一个数据，在被修改时，仍然能够保持修改前的状态，从本质来说，这种数据类型就是不可变类型，也就是immutable immutable.js提供了十余种不可变的类型（List，Map，Set，Seq，Collection，Range等） structural sharing （结构共享） immutable使用先进的tries(字典树)技术实现结构共享来解决性能问题，当我们对一个Immutable对象进行操作的时候，ImmutableJS会只clone该节点以及它的祖先节点，其他保持不变，这样可以共享相同的部分，大大提高性能。* support lazy operation （惰性操作） 这里有一个新的数据类型Seq，它有跟原生js类似的方法，但是性能却远远优于原生js123456789Immutable.Seq.of(1,2,3,4,5,6,7,8).filter(x=&gt;&#123; console.log('Immutable执行') return x%2&#125;)[1,2,3,4,5,6,7,8].filter(x=&gt;&#123; console.log('原生js执行') return x%2&#125;) 结果是上面的只执行3次，下面的代码执行了8次。 那么对于高频率的大量数据处理，这就意味着性能的优化。immutable.js的优缺点 优点 降低mutable带来的复杂度，甚至可以省略loadsh或者underscore的引入 节省内存 历史追溯性（时间旅行）：时间旅行指的是，每时每刻的值都被保留了，想回退到哪一步只要简单的将数据取出就行，想一下如果现在页面有个撤销的操作，撤销前的数据被保留了，只需要取出就行，这个特性在redux或者flux中特别有用 拥抱函数式编程：immutable本来就是函数式编程的概念，纯函数式编程的特点就是，只要输入一致，输出必然一致，相比于面向对象，这样开发组件和调试更方便 缺点 需要重新学习api 容易与原生对象混淆：由于api与原生不同，混用的话容易出错。 二.react+redux中集成immutable.js实践 为什么要使用redux中集成immutable React有一个奇怪的令人发指的特性，当一个组件更新的时候，他的子组件或者父组件都会发生更新，可能你只是修改了一个单选钮的样式，但是牵一发动全身，可能变化的是100个组件，所以react有个重要的性能优化的点就是shouldComponentUpdate。z爱这个生命周期钩子中，需要对数据进行比较，如果数据很大，层次很深，靠原生JS方法逐层比较，可能已经吐了，但是immutable.js,超级简。1a===b 明确边界 在redux中，全局state必须是immutable的，这点毋庸置疑是我们使用immutable来优化redux的核心 组件props是通过redux的connect从state中获得的，并且引入immutableJS的另一个目的是减少组件shouldComponentUpdate中不必要渲染，shouldComponentUpdate中比对的是props，如果props是原生JS就失去了优化的意义 组件内部state如果需要提交到store的，必须是immutable，否则不强制 view提交到action中的数据必须是immutable Action提交到reducer中的数据必须是immutable reducer中最终处理state必须是以immutable的形式处理并返回 与服务端ajax交互中返回的callback统一封装，第一时间转换成immutable数据 你体验过绝望么，只要你选择了immutable.js，对不起请忘记原生js，不然你写项目的时候可能就凉凉了。 具体注入方案 redux中，第一步肯定利用combineReducers来合并reducer并初始化state，redux自带的combineReducers只支持state是原生js形式的，所以这里我们需要使用redux-immutable提供的combineReducers来替换原来的方法12345678910import &#123;combineReducers&#125; from 'redux-immutable';import &#123;reducer as shop&#125; from './shop';import &#123;reducer as cart&#125; from './cart';import &#123;reducer as news&#125; from './news'; const rootReducer = combineReducers(&#123; shop, cart, news,&#125;); reducer中的initialState肯定也需要初始化成immutable类型 12345678const defaultState = &#123; products : Immutable.Map(&#123;&#125;);&#125;export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case SET_ERROR: &#125;&#125; 三. 总结 总的来说immutable.js的出现解决了许多原生js的痛点，并且自身对性能方面做了许多的优化处理，而且immuable.js作为和react同期推出的一个产品，完美的契合了react+redux的state流处理，redux的宗旨就是单一数据流，可追溯，这两点恰恰是immutable.js的优势，自然水到渠成，何乐而不为。 当然也不是所有使用react+redux的场景都需要使用immutable.js，建议满足项目足够大，state结构足够复杂的原则，小项目可以手动处理shouldComponentUpdate，不建议使用，得不偿失。 借鉴于big old]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[socket.io实现信息推送]]></title>
    <url>%2F2018%2F11%2F01%2Fsocket-io%E5%AE%9E%E7%8E%B0%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[WebSocket是html5新增加的一种通信协议，目前流行的浏览器都支持这个协。但是今天的主角socket.io将Websocket和轮询 （Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。相比较之下，使用它做实时，双向和基于事件的通信更加方便。 socket.io官网 准备工作 使用express自动生成一个后台文件目录(前提是你已经安装了(express),我习惯用ejs模板，虽然后面用不到。 1express --view=ejs 安装 socket.io，友情提示请在网络质量良好的情况下进行 1yarn add socket.io 起步 由于官网上提供的案例跟我的需求出入，请求的是后端资源。我的项目是前后端分离部署，后台数据更新后，给用户使用的移动端数据进行更新推送。我让后台和移动端项目同时去监听另外一个接口，通过这个接口作为一个桥梁，实现前后端通信。 后端初始化，启动一个本地服务器，端口号为9002 (这个端口应该没人用吧~) 123var server = require('http').createServer();var io = require('socket.io')(server);server.listen(9002); 前端初始化，引入socket.io 的js 文件，然后创建一个io对象，这个对象也监听着本地的9002端口。 12&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"&gt;&lt;/script&gt;var socket = io('http://localhost:9002'); 实现通信 后端通过监听socket.io 提供的事件，监听用户的状态 123456789//用户连接io.on('connection', function(socket)&#123; console.log('a user connected'); //用户断开连接 socket.on('disconnect', function()&#123; console.log('user disconnected'); &#125;);&#125;); 通过监听自定义事件，实现通信 前端，定义事件 1socket.emit('chat message', "hello world"); 后台，捕获事件 123456io.on('connection', function(socket)&#123; //监听前端chat message事件，如果触发，就在后台打印传递的msg socket.on('chat message', function(msg)&#123; console.log('message: ' + msg); &#125;);&#125;); 广播,可以给除了本人外的所有人发送一条信息123io.on('connection'，function(socket) &#123; socket.broadcast.emit('hi'); &#125;); ok,新技能get！撸代码了😭]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建属于自己的博客（二）]]></title>
    <url>%2F2018%2F10%2F05%2F%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说实话，系统提供的主题看起来真的丑，找来找去发现，next这个主题还是可以的，低调奢华有内涵，就很适合我这种高端大气上档次的boy。接下来我就说说怎么使用next主题打造一个狂拽炫酷吊炸天的个人博客，顺便po一下自己在搭建过程中遇到一些的问题和爬坑过程。 next入门 安装主题 在hexo文件夹的根目录下，使用git 下载最新的next主题 git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题，在hexo 的配置文件中，修改字段theme的值为next 验证主题，在命令行中执行下列代码，如果没有报错，就按照显示的地址在本地查看博客吧。 hexo s 设置主题next中有4个主题，可以通过选择 Scheme ，修改next的主题样式，一个一个去试就好了，我还是觉得Pisces比较干净。 设置语言编辑hexo的配置文件， 将字段 language 设置成你所需要的语言，修改完成后需要重新编译静态文件。乡下人英语不好，还是简体中文看着舒服。 language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 设置菜单编辑hexo的配置文件， 将字段 menu下打开需要属性。||前面是对应的页面，后面是icon小图标名称，使用的是fontawesome图标库，直接去fontawesome官网找吧，把名字复制过来替换即可。 menu: home: / || home about: /about/ || user categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive 有些新建的菜单选项可能没有文件夹，在点击时会报404页面，需要手动创建文件夹。可以在hexo根目录下执行下列命令 hexo new page “目录名称” 设置头像和网站的favicon图标编辑next文件夹中的主题配置文件（_config.yml）， 修改字段 avatar和favicon， 值设置成头像的链接地址。我一般把图片放在hexo根目录的source文件夹下自己创建的image文件夹中。 设置侧边栏社交链接和推荐链接打开主题配置文件（_config.yml）搜索social_icons:,在fontawesome官网找喜欢的小图标，将名字复制在如下位置。搜索links：，在这里可以添加推荐阅读的链接，如下图 next进阶 网站底部加上访问量 打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话 然后再合适的位置添加显示统计的代码123456&lt;div class="powered-by"&gt; &lt;i class="fa fa-user-md"&gt;&lt;/i&gt; &lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 uv的方式，单个用户连续点击n篇文章，只记录1次访客数注意这个东西在本地服务器上的数据都是假的，只有线上服务器才是真实数据。引入网易云音乐 我们可以通过网易云提供的外链播放器，让自己的博客自动播放音乐。将下面的代码复制到自己想要放置播放器的地方 这个播放器可以放在任何地方。我选择放在侧边栏中。1234&lt;div id="music163player"&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66"&gt; &lt;/iframe&gt;&lt;/div&gt; 注意 这里复制下来的地址中src是没有https:的 需要自己添加，不然无法生成播放器，这个坑我爬了一个晚上… 实现统计功能使用hexo-wordcount插件，实现博客字数和阅读时间的统计在hexo根目录下执行下列命令，安装插件 npm install hexo-wordcount –save 然后在主题配置文件中找到post_wordcount，将需要的东西改成true，即可实现该功能。 阅读次数统计我是使用leancloud来实现阅读次数的统计。首先需要去leancloud官网注册一下注册完成后，进入控制台，点击箭头指向的东西在存储中创建一个类 Counter 必须是这个命名然后获取appid和appkey将这两个值放到主题配置文件中leancloud_visitors下对应的字段1234leancloud_visitors: enable: true app_id: yourapp_id app_key: yourapp_key 最后在安全中心中，设置Web 安全域名同样这个数据在本地是无法计算的，而且会报错，只有上线后才能计算每次浏览的次数。 设置评论功能网上有一大堆开源的评论插件，类似来必力(韩国棒子出品，这不抵制一下？）、畅言、友言。最后发现上面一个leancloud也可以用来做评论，只不过需要配合Valine一起使用。 下载最新的Valine.min.js核心代码库到本地 将下载好的 Valine.min.js 放置于 next\source\js\src\下 打开valine配置文件进行配置,valine配置文件路径：next\layout\_third-party\comments\valine.swig if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;123456789101112131415161718192021222324252627282930313233343536 &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unjkp.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt; //删除Valine核心代码库外链调用 &lt;script src=&quot;/js/src/Valine.min.js&quot;&gt;&lt;/script&gt; //调用刚下载的本地文件以加速加载速度 &#123;% set valine_uri = &apos;/js/src/Valine.min.js&apos; %&#125; //这里改为从本地加载 &#123;% if theme.vendors.valine %&#125; &#123;% set valine_uri = theme.vendors.valine %&#125; &#123;% endif %&#125; &lt;script src=&quot;&#123;&#123; valine_uri &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var GUEST = [&apos;nick&apos;,&apos;mail&apos;,&apos;link&apos;]; var guest = &apos;&#123;&#123; theme.valine.guest_info &#125;&#125;&apos;; guest = guest.split(&apos;,&apos;).filter(function (item) &#123; return GUEST.indexOf(item)&gt;-1; &#125;); new Valine(&#123; el: &apos;#comments&apos; , verify: &#123;&#123; theme.valine.verify &#125;&#125;, notify: &#123;&#123; theme.valine.notify &#125;&#125;, appId: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;, appKey: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;, placeholder: &apos;&#123;&#123; theme.valine.placeholder &#125;&#125;&apos;, avatar:&apos;&#123;&#123; theme.valine.avatar &#125;&#125;&apos;, guest_info:[&apos;nick&apos;] , //评论者只需要提供评论的昵称即可 pageSize:&apos;&#123;&#123; theme.valine.pageSize &#125;&#125;&apos; || 10, &#125;); //增加以下六行代码去除 power by valine var infoEle = document.querySelector(&apos;#comments .info&apos;); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123; infoEle.childNodes.forEach(function(item) &#123; item.parentNode.removeChild(item); &#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; 然后去主题配置文件中进行修改，下面是我的配置 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true //打开valine评论功能 appid: 你的leancloud appid appkey: 你的leancloud appkey notify: false //邮件提醒 verify: true //评论时是否有验证码，需要在Leancloud 设置-&gt;安全中心 中打开 placeholder: 说点什么吧！ //评论框默认显示 avatar: hide //评论者的头像,我这里设置的不显示 guest_info: nick # custom comment header pageSize: 10 # pagination size 下面是效果图 为博客加上萌萌的宠物这个也是在找资料的时候发现的，虽然很好看，但是跟那个canvas背景图一样，有点占资源，可能会导致网站打开有点慢。下面是设置方法。 在hexo根目录下安装插件 npm install -save hexo-helper-live2d 宠物样式列表，选择你喜欢的萌妹子或者小动物，然后安装。 npm install live2d-widget-model-“宠物代码” 在hexo的配置文件中添加下列配置1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-z16 display: position: right width: 100 height: 150 mobile: show: true 我这个在本地运行好像不是很流畅，建议把mobile设置为false，因为手机上真的好占位置。。。下面是效果图别问我为啥选这个，老子晕奶！！！ 好了，暂时写这么多吧，感觉还有好多坑没有写进来。写完了还是蛮有成就感的，至少对得起掉下的这么多头发了。。。]]></content>
      <categories>
        <category>Hexo 搭建博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建属于自己的博客（一）]]></title>
    <url>%2F2018%2F09%2F30%2F%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近心血来潮，突然想搞一个自己的博客，虽然很早之前按就在博客园上注册过，总感觉有那么一丢丢low。网上查了查，发现Wordpressh和Hexo都还行，都支持安装自定义主题。Wordpress需要本地的数据库和支持后台操作，相比较下Hexo更加轻量级，那就这么愉快的决定了，let’s get it！ 准备工作 安装Node.js和配置好Node.js环境。 安装Git和配置好Git环境。 申请github账号，后面需要将项目上传至github上，使用它的服务器上线。 安装Hexo 全局安装Hexo，在自己认为合适的地方创个文件夹，在这个文件夹目录下打开命令行，执行下列代码。 1npm install hexo -g 检查hexo是否安装成功，如果出入一大堆版本号，就是成功了。 1hexo -v 在该文件夹下初始化hexo 1hexo init 看到后面的“Start blogging with Hexo！”，就代表成功咧，激不激动噻！ 安装hexo运行所需要的组建，建议在网络好的情况下进行，不然丢包出错真的不好查。。。 1npm install 编辑静态文件，手不要贱，等着就行。 1hexo g 启动hexo本地服务器，根据提示在浏览器中输入网址。 1hexo s 如果端口号被占用，执行下列代码1hexo server -p 端口号 如果出现下图就代表成功了 关联github 确保自己使用的电脑已经有生成公钥和密钥，并且在github上已经设置好。测试连接代码如下。 1ssh -T git@github.com 在github上创建一个新的仓库，项目必须要遵守格式：账户名.github.io，不然不能使用它本身提供的服务器。 配置Deployment,在根目录下找到_config.yml文件,修改deploy，一般在文件的最后面。repository后面改成自己仓库的SSH链接地址。 1234deploy: type: git repository: git@github.com:hzy1735/hzy1735.github.io.git branch: master 安装一个模块，用来进行自动打包提交。 1npm install hexo-deployer-git --save 制定打包提交命令 1hexo d -g 如果没有error，就是部署成功了，输入http://用户名.github.io，即可浏览自己的博客了 编写博客 在根目录下，命令行中输入下列代码，自动创建一个后缀为md的文件 1hexo new post “博客名” 由于Hexo的博客都是md文件，所以需要学一下md的语法，其实很简单，自行百度去吧。我是用vscode编写的，安装一个Markdown Preview Enhanced插件，就可以预览写出来的东西，vscode真牛逼！！！ 编写完成后，在执行打包提交代码，就能对线上的博客进行更新了。1hexo d -g 以上就是安装hexo和上线的操作咯，接下来还有更高级的操作咧。]]></content>
      <categories>
        <category>Hexo 搭建博客</category>
      </categories>
  </entry>
</search>
